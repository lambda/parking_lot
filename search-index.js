var searchIndex = {};
searchIndex["parking_lot"] = {"doc":"This library provides implementations of `Mutex`, `RwLock`, `Condvar` and `Once` that are smaller, faster and more flexible than those in the Rust standard library. It also provides a `ReentrantMutex` type.","items":[[3,"Once","parking_lot","A synchronization primitive which can be used to run a one-time initialization. Useful for one-time initialization for globals, FFI or related functionality.",null,null],[3,"Mutex","","A mutual exclusion primitive useful for protecting shared data",null,null],[3,"MutexGuard","","An RAII implementation of a \"scoped lock\" of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.",null,null],[3,"ReentrantMutex","","A mutex which can be recursively locked by a single thread.",null,null],[3,"ReentrantMutexGuard","","An RAII implementation of a \"scoped lock\" of a reentrant mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.",null,null],[3,"Condvar","","A Condition Variable",null,null],[3,"WaitTimeoutResult","","A type indicating whether a timed wait on a condition variable returned due to a time out or not.",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","RAII structure used to release the shared read access of a lock when dropped.",null,null],[3,"RwLockUpgradableReadGuard","","RAII structure used to release the upgradable read access of a lock when dropped.",null,null],[3,"RwLockWriteGuard","","RAII structure used to release the exclusive write access of a lock when dropped.",null,null],[4,"OnceState","","Current state of a `Once`.",null,null],[13,"New","","A closure has not been executed yet",0,null],[13,"Poisoned","","A closure was executed but panicked.",0,null],[13,"InProgress","","A thread is currently executing a closure.",0,null],[13,"Done","","A closure has completed sucessfully.",0,null],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",1,{"i":[{"n":"self"},{"n":"waittimeoutresult"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"waittimeoutresult"}],"o":{"n":"bool"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"waittimeoutresult"}}],[11,"timed_out","","Returns whether the wait was known to have timed out.",1,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new","","Creates a new condition variable which is ready to be waited on and notified.",2,{"o":{"n":"condvar"}}],[11,"notify_one","","Wakes up one blocked thread on this condvar.",2,{"i":[{"n":"self"}]}],[11,"notify_all","","Wakes up all blocked threads on this condvar.",2,{"i":[{"n":"self"}]}],[11,"wait","","Blocks the current thread until this condition variable receives a notification.",2,{"i":[{"n":"self"},{"n":"mutexguard"}]}],[11,"wait_until","","Waits on this condition variable for a notification, timing out after the specified time instant.",2,{"i":[{"n":"self"},{"n":"mutexguard"},{"n":"instant"}],"o":{"n":"waittimeoutresult"}}],[11,"wait_for","","Waits on this condition variable for a notification, timing out after a specified duration.",2,{"i":[{"n":"self"},{"n":"mutexguard"},{"n":"duration"}],"o":{"n":"waittimeoutresult"}}],[11,"default","","",2,{"o":{"n":"condvar"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new mutex in an unlocked state ready for use.",3,{"i":[{"n":"t"}],"o":{"n":"mutex"}}],[11,"into_inner","","Consumes this mutex, returning the underlying data.",3,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"lock","","Acquires a mutex, blocking the current thread until it is able to do so.",3,{"i":[{"n":"self"}],"o":{"n":"mutexguard"}}],[11,"try_lock","","Attempts to acquire this lock.",3,{"i":[{"n":"self"}],"o":{"g":["mutexguard"],"n":"option"}}],[11,"try_lock_for","","Attempts to acquire this lock until a timeout is reached.",3,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["mutexguard"],"n":"option"}}],[11,"try_lock_until","","Attempts to acquire this lock until a timeout is reached.",3,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["mutexguard"],"n":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",3,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"raw_unlock","","Releases the mutex.",3,{"i":[{"n":"self"}]}],[11,"raw_unlock_fair","","Releases the mutex using a fair unlock protocol.",3,{"i":[{"n":"self"}]}],[11,"raw_lock","","Acquires a mutex, blocking the current thread until it is able to do so.",3,{"i":[{"n":"self"}]}],[11,"raw_try_lock","","Attempts to acquire this lock.",3,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"default","","",3,{"o":{"n":"mutex"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"unlock_fair","","Unlocks the mutex using a fair unlock protocol.",4,{"i":[{"n":"self"}]}],[11,"map","","Make a new `MutexGuard` for a component of the locked data.",4,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"mutexguard"}}],[11,"deref","","",4,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"deref_mut","","",4,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"drop","","",4,{"i":[{"n":"self"}]}],[11,"new","","Creates a new reentrant mutex in an unlocked state ready for use.",5,{"i":[{"n":"t"}],"o":{"n":"reentrantmutex"}}],[11,"into_inner","","Consumes this reentrant mutex, returning the underlying data.",5,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"lock","","Acquires a reentrant mutex, blocking the current thread until it is able to do so.",5,{"i":[{"n":"self"}],"o":{"n":"reentrantmutexguard"}}],[11,"try_lock","","Attempts to acquire this lock.",5,{"i":[{"n":"self"}],"o":{"g":["reentrantmutexguard"],"n":"option"}}],[11,"try_lock_for","","Attempts to acquire this lock until a timeout is reached.",5,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["reentrantmutexguard"],"n":"option"}}],[11,"try_lock_until","","Attempts to acquire this lock until a timeout is reached.",5,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["reentrantmutexguard"],"n":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",5,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"raw_unlock","","Releases the mutex.",5,{"i":[{"n":"self"}]}],[11,"raw_unlock_fair","","Releases the mutex using a fair unlock protocol.",5,{"i":[{"n":"self"}]}],[11,"raw_lock","","Acquires a mutex, blocking the current thread until it is able to do so.",5,{"i":[{"n":"self"}]}],[11,"raw_try_lock","","Attempts to acquire this lock.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"default","","",5,{"o":{"n":"reentrantmutex"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"unlock_fair","","Unlocks the mutex using a fair unlock protocol.",6,{"i":[{"n":"self"}]}],[11,"map","","Make a new `ReentrantMutexGuard` for a component of the locked data.",6,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"reentrantmutexguard"}}],[11,"deref","","",6,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"drop","","",6,{"i":[{"n":"self"}]}],[11,"new","","Creates a new instance of an `RwLock<T>` which is unlocked.",7,{"i":[{"n":"t"}],"o":{"n":"rwlock"}}],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",7,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}],"o":{"n":"rwlockreadguard"}}],[11,"try_read","","Attempts to acquire this rwlock with shared read access.",7,{"i":[{"n":"self"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"try_read_for","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"try_read_until","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"read_recursive","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}],"o":{"n":"rwlockreadguard"}}],[11,"try_read_recursive","","Attempts to acquire this rwlock with shared read access.",7,{"i":[{"n":"self"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"try_read_recursive_for","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"try_read_recursive_until","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["rwlockreadguard"],"n":"option"}}],[11,"write","","Locks this rwlock with exclusive write access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}],"o":{"n":"rwlockwriteguard"}}],[11,"try_write","","Attempts to lock this rwlock with exclusive write access.",7,{"i":[{"n":"self"}],"o":{"g":["rwlockwriteguard"],"n":"option"}}],[11,"try_write_for","","Attempts to acquire this rwlock with exclusive write access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["rwlockwriteguard"],"n":"option"}}],[11,"try_write_until","","Attempts to acquire this rwlock with exclusive write access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["rwlockwriteguard"],"n":"option"}}],[11,"upgradable_read","","Locks this rwlock with upgradable read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}],"o":{"n":"rwlockupgradablereadguard"}}],[11,"try_upgradable_read","","Attempts to acquire this rwlock with upgradable read access.",7,{"i":[{"n":"self"}],"o":{"g":["rwlockupgradablereadguard"],"n":"option"}}],[11,"try_upgradable_read_for","","Attempts to acquire this rwlock with upgradable read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["rwlockupgradablereadguard"],"n":"option"}}],[11,"try_upgradable_read_until","","Attempts to acquire this rwlock with upgradable read access until a timeout is reached.",7,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["rwlockupgradablereadguard"],"n":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",7,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"raw_unlock_read","","Releases shared read access of the rwlock.",7,{"i":[{"n":"self"}]}],[11,"raw_unlock_write","","Releases exclusive write access of the rwlock.",7,{"i":[{"n":"self"}]}],[11,"raw_unlock_upgradable_read","","Releases upgradable read access of the rwlock.",7,{"i":[{"n":"self"}]}],[11,"raw_unlock_read_fair","","Releases shared read access of the rwlock using a fair unlock protocol.",7,{"i":[{"n":"self"}]}],[11,"raw_unlock_write_fair","","Releases exclusive write access of the rwlock using a fair unlock protocol.",7,{"i":[{"n":"self"}]}],[11,"raw_unlock_upgradable_read_fair","","Releases upgradable read access of the rwlock using a fair unlock protocol.",7,{"i":[{"n":"self"}]}],[11,"raw_downgrade","","Atomically downgrades a write lock into a shared read lock without allowing any writers to take exclusive access of the lock in the meantime.",7,{"i":[{"n":"self"}]}],[11,"raw_downgrade_upgradable_read","","Atomically downgrades an upgradable read lock into a shared read lock without allowing any writers to take exclusive access of the lock in the meantime.",7,{"i":[{"n":"self"}]}],[11,"raw_read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}]}],[11,"raw_try_read","","Attempts to acquire this rwlock with shared read access.",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"raw_read_recursive","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}]}],[11,"raw_try_read_recursive","","Attempts to acquire this rwlock with shared read access.",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"raw_write","","Locks this rwlock with exclusive write access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}]}],[11,"raw_try_write","","Attempts to lock this rwlock with exclusive write access.",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"raw_upgradable_read","","Locks this rwlock with upgradable read access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}]}],[11,"raw_try_upgradable_read","","Attempts to acquire this rwlock with upgradable read access.",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"raw_upgrade","","Upgrades this rwlock from upgradable read access to exclusive write access, blocking the current thread until it can be acquired.",7,{"i":[{"n":"self"}]}],[11,"raw_try_upgrade","","Attempts to upgrade this rwlock from upgradable read access to exclusive write access.",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"default","","",7,{"o":{"n":"rwlock"}}],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",8,{"i":[{"n":"self"}]}],[11,"map","","Make a new `RwLockReadGuard` for a component of the locked data.",8,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"rwlockreadguard"}}],[11,"deref","","",8,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"drop","","",8,{"i":[{"n":"self"}]}],[11,"downgrade","","Atomically downgrades a write lock into a read lock without allowing any writers to take exclusive access of the lock in the meantime.",9,{"i":[{"n":"self"}],"o":{"n":"rwlockreadguard"}}],[11,"map","","Make a new `RwLockWriteGuard` for a component of the locked data.",9,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"rwlockwriteguard"}}],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",9,{"i":[{"n":"self"}]}],[11,"deref","","",9,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"deref_mut","","",9,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"drop","","",9,{"i":[{"n":"self"}]}],[11,"downgrade","","Atomically downgrades an upgradable read lock lock into a shared read lock without allowing any writers to take exclusive access of the lock in the meantime.",10,{"i":[{"n":"self"}],"o":{"n":"rwlockreadguard"}}],[11,"upgrade","","Atomically upgrades an upgradable read lock lock into a exclusive write lock, blocking the current thread until it can be aquired.",10,{"i":[{"n":"self"}],"o":{"n":"rwlockwriteguard"}}],[11,"try_upgrade","","Tries to atomically upgrade an upgradable read lock into a exclusive write lock.",10,{"i":[{"n":"self"}],"o":{"g":["rwlockwriteguard"],"n":"result"}}],[11,"try_upgrade_for","","Tries to atomically upgrade an upgradable read lock into a exclusive write lock, until a timeout is reached.",10,{"i":[{"n":"self"},{"n":"duration"}],"o":{"g":["rwlockwriteguard"],"n":"result"}}],[11,"try_upgrade_until","","Tries to atomically upgrade an upgradable read lock into a exclusive write lock, until a timeout is reached.",10,{"i":[{"n":"self"},{"n":"instant"}],"o":{"g":["rwlockwriteguard"],"n":"result"}}],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",10,{"i":[{"n":"self"}]}],[11,"deref","","",10,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"drop","","",10,{"i":[{"n":"self"}]}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"oncestate"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"oncestate"}],"o":{"n":"bool"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"poisoned","","Returns whether the associated `Once` has been poisoned.",0,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"done","","Returns whether the associated `Once` has successfullly executed a closure.",0,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new","","Creates a new `Once` value.",11,{"o":{"n":"once"}}],[11,"state","","Returns the current state of this `Once`.",11,{"i":[{"n":"self"}],"o":{"n":"oncestate"}}],[11,"call_once","","Performs an initialization routine once and only once. The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will not be invoked.",11,{"i":[{"n":"self"},{"n":"f"}]}],[11,"call_once_force","","Performs the same function as `call_once` except ignores poisoning.",11,{"i":[{"n":"self"},{"n":"f"}]}],[11,"default","","",11,{"o":{"n":"once"}}],[11,"fmt","","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[0,"deadlock","","[Experimental] Deadlock detection",null,null],[5,"check_deadlock","parking_lot::deadlock","Returns all deadlocks detected since the last call. Each cycle consist of a vector of `DeadlockedThread`.",null,{"o":{"g":["vec"],"n":"vec"}}],[6,"MutexGuardRef","parking_lot","Typedef of an owning reference that uses a `MutexGuard` as the owner.",null,null],[6,"ReentrantMutexGuardRef","","Typedef of an owning reference that uses a `ReentrantMutexGuard` as the owner.",null,null],[6,"RwLockReadGuardRef","","Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.",null,null],[6,"RwLockWriteGuardRef","","Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.",null,null],[6,"RwLockUpgradableReadGuardRef","","Typedef of an owning reference that uses a `RwLockUpgradableReadGuard` as the owner.",null,null],[17,"ONCE_INIT","","Initialization value for static `Once` values.",null,null]],"paths":[[4,"OnceState"],[3,"WaitTimeoutResult"],[3,"Condvar"],[3,"Mutex"],[3,"MutexGuard"],[3,"ReentrantMutex"],[3,"ReentrantMutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"RwLockUpgradableReadGuard"],[3,"Once"]]};
searchIndex["parking_lot_core"] = {"doc":"This library exposes a low-level API for creating your own efficient synchronization primitives.","items":[[3,"ParkToken","parking_lot_core","A value associated with a parked thread which can be used by `unpark_filter`.",null,null],[12,"0","","",0,null],[3,"UnparkResult","","Result of an unpark operation.",null,null],[12,"unparked_threads","","The number of threads that were unparked.",1,null],[12,"have_more_threads","","Whether there are any threads remaining in the queue. This only returns true if a thread was unparked.",1,null],[12,"be_fair","","This is set to true on average once every 0.5ms for any given key. It should be used to switch to a fair unlocking mechanism for a particular unlock.",1,null],[3,"UnparkToken","","A value which is passed from an unparker to a parked thread.",null,null],[12,"0","","",2,null],[3,"SpinWait","","A counter used to perform exponential backoff in spin loops.",null,null],[4,"FilterOp","","Operation that `unpark_filter` should perform for each thread.",null,null],[13,"Unpark","","Unpark the thread and continue scanning the list of parked threads.",3,null],[13,"Skip","","Don't unpark the thread and continue scanning the list of parked threads.",3,null],[13,"Stop","","Don't unpark the thread and stop scanning the list of parked threads.",3,null],[4,"ParkResult","","Result of a park operation.",null,null],[13,"Unparked","","We were unparked by another thread with the given token.",4,null],[13,"Invalid","","The validation callback returned false.",4,null],[13,"TimedOut","","The timeout expired.",4,null],[4,"RequeueOp","","Operation that `unpark_requeue` should perform.",null,null],[13,"Abort","","Abort the operation without doing anything.",5,null],[13,"UnparkOneRequeueRest","","Unpark one thread and requeue the rest onto the target queue.",5,null],[13,"RequeueAll","","Requeue all threads onto the target queue.",5,null],[5,"park","","Parks the current thread in the queue associated with the given key.",null,{"i":[{"n":"usize"},{"n":"v"},{"n":"b"},{"n":"t"},{"n":"parktoken"},{"g":["instant"],"n":"option"}],"o":{"n":"parkresult"}}],[5,"unpark_all","","Unparks all threads in the queue associated with the given key.",null,{"i":[{"n":"usize"},{"n":"unparktoken"}],"o":{"n":"usize"}}],[5,"unpark_filter","","Unparks a number of threads from the front of the queue associated with `key` depending on the results of a filter function which inspects the `ParkToken` associated with each thread.",null,{"i":[{"n":"usize"},{"n":"f"},{"n":"c"}],"o":{"n":"unparkresult"}}],[5,"unpark_one","","Unparks one thread from the queue associated with the given key.",null,{"i":[{"n":"usize"},{"n":"c"}],"o":{"n":"unparkresult"}}],[5,"unpark_requeue","","Removes all threads from the queue associated with `key_from`, optionally unparks the first one and requeues the rest onto the queue associated with `key_to`.",null,{"i":[{"n":"usize"},{"n":"usize"},{"n":"v"},{"n":"c"}],"o":{"n":"unparkresult"}}],[11,"new","","Creates a new `SpinWait`.",6,{"o":{"n":"spinwait"}}],[11,"reset","","Resets a `SpinWait` to its initial state.",6,{"i":[{"n":"self"}]}],[11,"spin","","Spins until the sleep threshold has been reached.",6,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"spin_no_yield","","Spins without yielding the thread to the OS.",6,{"i":[{"n":"self"}]}],[11,"default","","",6,{"o":{"n":"spinwait"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"parkresult"}}],[11,"eq","","",4,{"i":[{"n":"self"},{"n":"parkresult"}],"o":{"n":"bool"}}],[11,"ne","","",4,{"i":[{"n":"self"},{"n":"parkresult"}],"o":{"n":"bool"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"is_unparked","","Returns true if we were unparked by another thread.",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"unparkresult"}}],[11,"eq","","",1,{"i":[{"n":"self"},{"n":"unparkresult"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"unparkresult"}],"o":{"n":"bool"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"requeueop"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"requeueop"}],"o":{"n":"bool"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"filterop"}}],[11,"eq","","",3,{"i":[{"n":"self"},{"n":"filterop"}],"o":{"n":"bool"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"unparktoken"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"unparktoken"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"unparktoken"}],"o":{"n":"bool"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"parktoken"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"parktoken"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"parktoken"}],"o":{"n":"bool"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[0,"deadlock","","[Experimental] Deadlock detection",null,null],[5,"acquire_resource","parking_lot_core::deadlock","Acquire a resource identified by key in the deadlock detector Noop if deadlock_detection feature isn't enabled. Note: Call after the resource is acquired",null,{"i":[{"n":"usize"}]}],[5,"release_resource","","Release a resource identified by key in the deadlock detector. Noop if deadlock_detection feature isn't enabled. Note: Call before the resource is released # Panics Panics if the resource was already released or wasn't acquired in this thread.",null,{"i":[{"n":"usize"}]}],[5,"check_deadlock","","Returns all deadlocks detected since the last call. Each cycle consist of a vector of `DeadlockedThread`.",null,{"o":{"g":["vec"],"n":"vec"}}],[17,"DEFAULT_PARK_TOKEN","parking_lot_core","A default park token to use.",null,null],[17,"DEFAULT_UNPARK_TOKEN","","A default unpark token to use.",null,null]],"paths":[[3,"ParkToken"],[3,"UnparkResult"],[3,"UnparkToken"],[4,"FilterOp"],[4,"ParkResult"],[4,"RequeueOp"],[3,"SpinWait"]]};
initSearch(searchIndex);
